link strings
link ximage
global sock_list, config, HTTPSGLOB
class TCPSession(sock)
#<p>
#	The method <tt>tcp_session</tt> makes different threads in one session
#</p>
   method tcp_session()
      Logger.logInfoWrite("new thread, id: " || serial() || "  socket:", image(sock))
      repeat {
         if *select(sock) > 0 then {
            if msg := ready(sock) then {      # read whatever available on the socket
               msg := replace(msg, "\\r\\n" , "\r\n")
			   Logger.logInfoWrite(image(sock) || " : " || image(msg))
		
			 if msg == "" then next 
			 if /msg then next
			 req:=Request(msg)
			 
			 req_resp:=Request_Response(req) 
			 writes(sock,req_resp.response)                     # send back to the client

               
               }
            else {  # We see activity on the socket but nothing to read, assume client has closed the socket
	       Logger.logInfoWrite("closing socket: " || image(sock))
               delete(sock_list, sock)
               close(sock)
               break # done, break out of the loop
            }
         }
      }
   end
   initially(s)
      sock := s
      thread tcp_session()
end
class TCPServer(addrport)
#<p>
#	The method <tt>run</tt> waits for a new client to connect
#</p>
   method run()
      write("Server running at ", addrport, "  Press CTRL+C to stop...")
      # The main thread is just a thread orchestrator
      # every time a client connects, a new thread is created to handle it
      repeat {
         sock := tcp_socket(addrport) # block and wait to accept a new connection
         write("launching a new thread...")
         TCPSession(sock)
       }
   end
#<p>
#	The method <tt>tcp_socket</tt> opens the server
#</p>	   
   method tcp_socket()
      write("Open tcp socket at ", addrport)
      s := open(addrport, "na") |
           stop("open(",s,") ERROR: ", &errortext)
      insert(sock_list, s)
      return s
   end
   initially(p)
      addrport := p
end
link basename
link xoptions
#<p>
#	The procedure <tt>usage</tt> sends the correct format to run the server
#</p>
procedure usage()
   prog := basename(&progname)
   write("Usage: ", prog, " [options]\n")
   write(prog, " is a unicon http server")
   write("Options:")
   write("\t -a : address to bind to, default to any addr")
   write("\t -p : port to use, default to 8080")
   write("\t -h : show this help\n")
   exit(-1)
end

# Initializes the global config table using data from the configuration file
procedure read_config(config_name)
	local f, line, header, body
	f := open(config_name) | stop("ERROR: ", config_name, "could not be opened")
	config := table()
	while line := read(f) do {
		line ? {
			header := tab(find(" "))
			move(3)
			body := tab(0)
			config[header] := body
		}
	}
end

# Returns a set of file type strings from a string delimeted by white space
procedure get_file_type_set(str)
	local file_type_set, wchar, word
	file_type_set := set()
	wchar := &letters ++ '.'
	str ? while tab(upto(wchar)) do {
		word := tab(many(wchar))
		insert(file_type_set, word)
	}
	return file_type_set
end

# Returns the filetype of a file or path.
procedure get_file_type(str)
	filesuf = suffix(str)
	return "." || filesuf[2]
end

class Logger(log_file, log_level)
	# Ideally this method would be private
        method log(msg, logType)
                writes(log_file, "[", &date, " ",  &clock, "] ", logType, ":", msg, "\n")
        end

	method logDbg(msg[])
		if log_level >= 4 then  {
			self.log(concatList(msg), "DEBUG")
		}
	end

	method logInfo(msg[])
		if log_level >= 3 then  {
			self.log(concatList(msg), "INFO")
		}
	end
	method logWarn(msg[])
		if log_level >= 2 then  {
			self.log(concatList(msg), "WARNING")
		}
	end
	method logError(msg[])
		if log_level >= 1 then  {
			self.log(concatList(msg), "ERROR")
		}
	end

	method logInfoWrite(msg[])
		self.logInfo(concatList(msg))
		write(concatList(msg))
	end

        method concatList(L)
                s := ""
                every s ||:= !L
                return s
        end

	# NONE: 0
	# ERROR: 1
	# WARN: 2
	# INFO: 3
	# DEBUG: 4
        initially(log_file_path, init_log_level)
		/init_log_level := 4
		log_level := init_log_level
                log_file := open(log_file_path, "a")
		Logger := self
end

#<p>
#	The procedure <tt>main</tt> calls the run method to start the server
#		<[param args arguments from the command line]>
#</p>
procedure main(args)
   local opts, port, addr
   read_config("config.ini")
   # Reads the table for the HTTPS Flag and sets it.
   HTTPSGLOB := config["HTTPS_FLAG"]
   Logger("server_log.txt", config["LOG_LEVEL"])
   opts := xoptions(args, "ha:p+")
   /opts["h"] | usage()
   addr := \opts["a"] | ""
   port := \opts["p"] | "8080"
   0 < port < 65536 | stop("invalid port: ", port)
   sock_list := mutex(set())
   trap("SIGINT", sig)
   tcp_server := TCPServer(addr || ":" || port)
   tcp_server.run()
end
#<p>
#	The procedure <tt>sig</tt> closes the server and its threads if an attempt to close the server is caught
#</p>
procedure sig(siganl)
   write("\nshutdown signal received! Server Shutting down...")
   every close(!sock_list) || &error := 1
   exit(0)
end


class Request(
    request_line,
    header_fields,
    body,
    form,
    request_target,
    http_version,
    status,
	response
    )
#<p>
#	The method <tt>parse_request</tt> separates out the request line and the header fields, returns String response
#		<[param msg String client sent]>
#</p>	
    method parse_request(msg)
        if /msg then {
            status:=handle_status("400")
            response:=status.message
			return response
        }
		

        
        if msg ?{
          request_line := tab(find("\r\n"))
          move(2)
          line := tab(find("\r\n"))
          if /line then {
			s:=handle_status("400")
			response:=s.message
			return response
			}
          while line ~== "" do {
             put(header_fields, line)
             move(2)
             line := tab(find("\r\n"))
             }
          move(2)
          body := tab(0) 
        
        }then {
            parse_request_line(request_line)
            return
        }
		
        s:=handle_status("400")
		response:=s.message
		return response
    end
#<p>
#	The method <tt>parse_request_line</tt> seperates out the form from the other parts of the request_line
#		<[param request_line String containing the request line]>
#</p>
    method parse_request_line(request_line)
        request_line ? {
            form := tab(find(" "))
            move(2)
            request_target := tab(find(" "))
            move(1)
            http_version := tab(0)
        }   
    end
#<p>
#	The method <tt>parse_header_fields</tt> is not used
#</p>
    method parse_header_fields(header_fields)
        every line := !header_fields do {       
            line ? {                
                line := tab(find(":"))
                move(2)
                line2:= tab(0)
                header_fields[line]:=line2
            }
        }
    end
#<p>
#	The method <tt>get_request_line</tt> gets the request_line variable
#</p>
	method get_request_line()
		return request_line
	end
    
    initially(message)
        msg:=message
        header_fields:=[]
		status:="200"
		parse_request(msg)
end

class Request_Response(
    header_fields,
    body,
    form,
    request_target,
    http_version,
    status,
	response,
	type
	)
#<p>
#	The method <tt>handle_request</tt> calls the method associated with the request
#		<[param form String of request type]>
#		<[return handle_? the response to the request]>
#</p>
	method handle_request(form)

		case form of{
			"HEAD" : return handle_HEAD()
			"GET" : return handle_GET()
			"DELETE" : return handle_DELETE()
			"PUT" : return handle_PUT()
			"POST": return handle_POST()
			default: {  s:=handle_status("400")
						response:=s.message
						return response}
		}
	end
#<p>
#	The method <tt>handle_HEAD</tt> gets the data associated with a Head request using the stat method
#		<[return response the response to the Head request]>
#</p>
	method handle_HEAD()
		filename:=request_target
		filename?{
			tab(find("."))
			file_type:=tab(0)
		}
		type:=Mime(file_type)
		st := stat(filename) | { s:=handle_status("404")
								response:=s.message
								return response}
			s:=handle_status(status)
			response := http_version||" "||s.message||"\r\nDate:"||&date||" "||&clock||"\r\nServer: Unicon Server"||"\r\nLast-Modified: "||ctime(st.mtime)||"\r\nETag: \""||hash(st.mtime)||"\"\r\nVary: Authorization,Accept\r\nAccept-Ranges: bytes\r\nContent-Length: "||st.size||"\r\nContent-Type: "||type.MIME_type||"\r\nConnection: keep-alive"
			return response
			
	end
#<p>
#	The method <tt>handle_GET</tt> gets the data associated with a Get request
#		<[return response the response to the Get request]>
#</p>
	method handle_GET()
		
		if /request_target then { s:=handle_status("400")
								response:=s.message
								return response}
		if request_target=="" then{
			filename:="index.html"
			#filename:="helloworld.jpg"
			#filename:="matt_index.html"
		}else{
			filename:=request_target
		}
		
		filename?{
			tab(find("."))
			file_type:=tab(0)
		}
	
		type:=Mime(file_type)
		
		if(file_type==".jpg"|".gif"|".jpeg"|".png"|".bmp") then{
			fin := open(filename,"ru")| {
				s:=handle_status("404")
				response:=s.message
				t:=http_version||" "|| response
				return t
			}
			if p := stat(fin)then(
				data := reads(fin, p.size)|fail
			
			)else{ s:=handle_status("404")
						response:=s.message
						return response} 
			
			close(fin)
		}else{
			fin := open(filename)| {
				s:=handle_status("404")
				response:=s.message
				t:=http_version||" "|| response
				return t
			}
			if p := stat(fin)then(
				data := reads(fin, p.size)|fail
			
			)else{s:=handle_status("404")
				response:=s.message
				t:=http_version||" "|| response
				return t}
			
			close(fin)
		}
		
		st:=stat(filename)
		s:=handle_status(status)
		
		response:=http_version||" "||s.message||"\r\nDate:"||&date||" "||&clock||"\r\nServer: Unicon Server"||"\r\nLast-Modified: "||ctime(st.mtime)||"\r\nETag: \""||hash(st.mtime)||"\"\r\nVary: Authorization,Accept\r\nAccept-Ranges: bytes\r\nContent-Length: "||st.size||"\r\nContent-Type: "||type.MIME_type||"\r\nConnection: keep-alive"

		response:=response||"\r\n\r\n"||data
		
		
		return response
			
	end
#<p>
#	The method <tt>handle_DELETE</tt> removes the requested file
#		<[return response confirmation of the removal]>
#</p>

        method handle_DELETE()
                if request_target==""|/request_target then{
                        s:=handle_status("400")
                        response:=s.message
                        return response
                }
                filename := request_target
                filetype := get_file_type(filename)
                allowed_file_types := get_file_type_set(config["DELETE_File_Types"])
                if member(allowed_file_types, "any") | member(allowed_file_types, filetype) then {
			remove(filename)
			s:=handle_status("200")
			response:=s.message
			return response
                } else {
                        s := handle_status("403")
                        response := s.message
                        return response
		}
        end

#<p>
#	The method <tt>handle_PUT</tt> adds a file with the data sent by the client, or replaces it if it already exits
#		<[return response confirmation of the placement]>
#</p>
	method handle_PUT()
		if (request_target==""|/request_target) then {
			s:=handle_status("400")
			response:=s.message
			return response
		} else {
			filename:=request_target
			filetype := get_file_type(filename)
			allowed_file_types := get_file_type_set(config["PUT_File_Types"])
			
			if not member(allowed_file_types, "any") & not member(allowed_file_types, filetype) then {
	                        s := handle_status("403")
        	                response := s.message
               	        	return response
			}
			
			if stat(filename) then {
			#check if request_target exists in directory (204)
				f:= open(filename, "w")
				write(f, body)
				close(f)
				s:=handle_status("200")
				response:=s.message
				return response
			} else {
				#if request_target doesn't exists in directory (201)
				f := open(filename, "w")
				write(f, body)
				close(f)
				s := handle_status("201")
				response := s.message
				return response
			}
		}
	end
#<p>
#	The method <tt>handle_POST</tt> adds a file with the data sent by the client, it is not idempotent
#		<[return response confirmation of the creation]>
#</p>
	method handle_POST()
		if (request_target==""|/request_target) then { 
			s:=handle_status("400")
			response:=s.message
			return response
		} else {
			filename := request_target
			filetype := get_file_type(filename)
			allowed_file_types := get_file_type_set(config["POST_File_Types"])

			if not member(allowed_file_types, "any") & not member(allowed_file_types, filetype) then {
				s := handle_status("403")
				response := s.message
				return response
			}
		
			if stat(filename) then {
				s := handle_status("409")
				response := s.message
				return response
			} else {
				f := open(filename, "w")
				write(f, body)
				close(f)
				s := handle_status("201")
				response := s.message
				return response
			}
		}	
	end
#<p>
#	The method <tt>hash</tt> takes a random input and makes a hash value from it. Used for the etag
#		<[param s int to hash]>
#		<[return i hashed int]>
#</p>
	method hash(s)
		local i := 0
		every i +:= ord(s[1 to min(*s, 10)]) do
		i *:= 37
		i +:= *s
		return i
	end


	initially(request)
		form:=request.form
		request_target:=request.request_target
		http_version:=request.http_version
		header_fields:=request.header_fields
		body:=request.body
		status:="200"
		handle_request(form)
		
end

class Mime(MIME_type,
	type,
	FileTable
)
#<p>
#	The method <tt>get_MIME</tt> returns the file extension
#		<[param type String of file extension]>
#		<[return "type" the name of the extension]>
#</p>
	method get_MIME(type)
		return FileTable[type]
	end
	
	method build_Table()
		# Poor readability, might want to change to individual assignments for easier reading in the future.
		insert(FileTable,".aac","audio/aac",".abw","application/x-abiword",".arc","application/x-freearc",".avi","video/x-msvideo",".azw","application/vnd.amazon.ebook",".bin","application/octet-stream",".bmp","image/bmp",".bz","application/x-bzip",".bz2","application/x-bzip2",".cda","application/x-cdf",".csh","application/x-csh",".css","text/css",".csv","text/csv",".doc","application/msword",".docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document",".eot","application/vnd.ms-fontobject",".epub","application/epub+zip",".gz","application/gzip",".gif","image/gif",".htm","text/html",".html","text/html",".ico","image/vnd.microsoft.icon",".ics","text/calendar",".jar","application/java-archive",".jpeg","image/jpeg",".jpg","image/jpeg",".js","text/javascript",".json","application/json",".jsonld","application/ld+json",".mid","audio/midi",".midi","audio/x-midi",".mjs","text/javascript",".mp3","audio/mpeg",".mp4","video/mp4",".mpeg","video/mpeg",".mpkg","application/vnd.apple.installer+xml",".odp","application/vnd.oasis.opendocument.presentation",".ods","application/vnd.oasis.opendocument.spreadsheet",".odt","application/vnd.oasis.opendocument.text",".oga","audio/ogg",".ogv","video/ogg",".ogx","application/ogg",".opus","audio/opus",".otf","font/otf",".png","image/png",".pdf","application/pdf",".php","application/x-httpd-php",".ppt","application/vnd.ms-powerpoint",".pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation",".rar","application/vnd.rar",".rtf","application/rtf",".sh","application/x-sh",".svg","image/svg+xml",".swf","application/x-shockwave-flash",".tar","application/x-tar",".tif","image/tiff",".tiff","image/tiff",".ts","video/mp2t",".ttf","font/ttf",".txt","text/plain",".vsd","application/vnd.visio",".wav","audio/wav",".weba","audio/webm",".webm","video/webm",".webp","image/webp",".woff","font/woff",".woff2","font/woff2",".xhtml","application/xhtml+xml",".xls","application/vnd.ms-excel",".xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",".xml","application/xml",".xul","application/vnd.mozilla.xul+xml",".zip","application/zip",".3gp","video/3gpp",".3g2","video/3gpp2",".7z","application/x-7z-compressed")
	end

	initially(in_type)
		type:=in_type
		FileTable := table("File extension does not exist.")
		build_Table()
		MIME_type:=get_MIME(type)
end

class handle_status(code,
	message
	)
#<p>
#	The method <tt>handle_status_code</tt> gets the number code and returns the number and status code meaning
#		<[param code String status code]>
#		<[return "Code" the name of the code value]>
#</p>
    method handle_status_code(code
	)
        
        case code of{
		#	Informational 1xx
		"100" : return "100 Continue"
		"101" : return "101 Switching Protocols"

		#	Successful 2xx
		"200" : return "200 OK"
		"201" : return "201 Created"
		"202" : return "202 Accepted"
		"203" : return "203 Non-Authoritative Information"
		"204" : return "204 No Content"
		"205" : return "205 Reset Content"

		#	Redirection 3xx
		"300" : return "300 Multiple Choices"
		"301" : return "301 Moved Permanently" 
		"302" : return "302 Found"
		"303" : return "303 See Other"
		"305" : return "305 Use Proxy"
				   
		#	Client Error 4xx
		"400" : return "400 Bad Request"
		"402" : return "402 Payment Required"
		"403" : return "403 Forbidden"
		"404" : return "404 Not Found"
		"405" : return "405 Method Not Allowed"
		"406" : return "406 Not Acceptable"
		"408" : return "408 Request Timeout"
		"409" : return "409 Conflict"
				   
		#	Server Error 5xx
		"500" : return "500 Internal Server Error"
		"501" : return "501 Not Implemented"
		"502" : return "502 Bad Gateway"
		"503" : return "503 Service Unavailable"
		"504" : return "504 Gateway Timeout"
		"505" : return "505 HTTP Version Not Supported"

		
		}
		
    end
        
        
    initially(scode)
        code:=scode
		message:=handle_status_code(code)
        
end
